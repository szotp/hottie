import 'dart:convert';
import 'dart:io';
import 'dart:isolate';

import 'package:args/command_runner.dart';
import 'package:hottie/src/utils/logger.dart';

const _mainPath = 'build/hottie_main.dart';
const _testsPath = 'build/hottie_tests.g.dart';

class TestFileHandle {
  TestFileHandle(this.packageName, this.uniqueId, this.uri);

  final String packageName;
  final String uniqueId;
  final Uri uri;

  static TestFileHandle? parse(FileSystemEntity file, Set<String> usedIds) {
    if (!file.path.endsWith('_test.dart') || file.path.contains('/.')) {
      return null;
    }

    final segments = file.uri.pathSegments;
    final testIndex = segments.indexOf('test');

    if (testIndex < 0) {
      return null;
    }

    final packageName = segments[testIndex - 1];
    final proposedId = segments.last.replaceAll('.dart', '');
    var uniqueId = proposedId;

    for (var i = 2; i < 100; i++) {
      if (usedIds.add(uniqueId)) {
        break;
      }
      uniqueId = '${proposedId}_$i';
    }

    return TestFileHandle(packageName, uniqueId, file.uri);
  }
}

class TestFileHandles {
  TestFileHandles(this.all);

  final List<TestFileHandle> all;

  late final List<String> packages = all.map((x) => x.packageName).toSet().toList()..sort();
}

TestFileHandles findTestsInCurrentDirectory() {
  final usedIds = <String>{};
  final files = Directory.current.listSync(recursive: true).map((file) => TestFileHandle.parse(file, usedIds)).nonNulls.toList();

  if (files.isEmpty) {
    logger.warning('No test files found in ${Directory.current}');
  }
  return TestFileHandles(files);
}

Future<String> determinHottieInsiderImport() async {
  // parse package config and check if hottie is available. if yes, return normal import
  final packageConfigFile = File('.dart_tool/package_config.json');

  if (!packageConfigFile.existsSync()) {
    throw Exception('.dart_tool/package_config.json not found. Run flutter pub get first.');
  }

  final packageConfigJson = jsonDecode(await packageConfigFile.readAsString()) as Map<String, dynamic>;
  final packages = packageConfigJson['packages'] as List<dynamic>;

  final hottiePackage = packages.firstWhere(
    (pkg) => (pkg as Map)['name'] == 'hottie',
    orElse: () => null,
  );

  if (hottiePackage != null) {
    // hottie package is available, use normal package import
    return "import 'package:hottie/hottie_insider.dart';";
  } else {
    // hottie not available as package, fall back to resolved path
    final resolved = await Isolate.resolvePackageUri(Uri.parse('package:hottie/hottie_insider.dart'));
    return "import '$resolved';";
  }
}

Future<Uri> generateMain(TestFileHandles testPaths, {bool overrideMain = false}) async {
  final hottieImport = await determinHottieInsiderImport();

  final buffer = StringBuffer();
  buffer.writeln('// GENERATED BY hottie. Do not edit');
  buffer.writeln('// ignore_for_file: constant_identifier_names - preserve file names');
  buffer.writeln(hottieImport);

  for (final handle in testPaths.all) {
    buffer.writeln("import '${handle.uri}' as import_${handle.uniqueId};");
  }

  buffer.writeln('extension FoundPackageNames on PackageName {');
  for (final package in testPaths.packages) {
    buffer.writeln("  static const $package = '$package';");
  }
  buffer.writeln('}');

  for (final handle in testPaths.all) {
    buffer.writeln("const ${handle.uniqueId} = TestFile('${handle.uri}', import_${handle.uniqueId}.main);");
  }

  buffer.writeln('const TestMap allTests = [');

  for (final handle in testPaths.all) {
    buffer.writeln('${handle.uniqueId},');
  }

  buffer.writeln('];');

  if (!Directory('build').existsSync()) {
    Directory('build').createSync();
  }
  File(_testsPath).writeAsStringSync(buffer.toString());

  if (!File(_mainPath).existsSync() || overrideMain) {
    final hottieMain = await Isolate.resolvePackageUri(Uri.parse('package:hottie/src/template/hottie_main.dart'));
    final contents = File.fromUri(hottieMain!).readAsLinesSync();
    final index = contents.indexWhere((x) => x.contains('hottie_insider'));
    contents[index] = hottieImport;

    File(_mainPath).writeAsStringSync(contents.join('\n'));
  }

  return Uri.file(_mainPath);
}

class GenerateCommand extends Command<void> {
  GenerateCommand() {
    argParser.addFlag('overrideMain');
  }
  @override
  String get description => 'generate hottie tests file';
  @override
  String get name => 'generate';

  @override
  Future<void>? run() async {
    final testPaths = findTestsInCurrentDirectory();
    final hottieUri = await generateMain(testPaths, overrideMain: argResults!.flag('overrideMain'));
    logger.info('Generated $hottieUri');
  }
}
